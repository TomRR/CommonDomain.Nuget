namespace CommonDomain.Core.Generators.ValueObjects;


/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class ValueObjectBaseGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Filter classes annotated with the [Report] attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax || s is StructDeclarationSyntax || s is RecordDeclarationSyntax,
                (ctx, _) => GetTypeDeclarationForSourceGen(ctx))
            .Where(t => t.reportAttributeFound)
            .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    private static (TypeDeclarationSyntax, bool reportAttributeFound) GetTypeDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        if (context.Node is not TypeDeclarationSyntax typeDeclarationSyntax)
            return (null!, false);

        foreach (var attributeListSyntax in typeDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
                continue;

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();
            if (attributeName.Contains("ValueObject"))
                return (typeDeclarationSyntax, true);
        }

        return (typeDeclarationSyntax, false);
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes (ClassDeclarationSyntax annotated with the [Report] attribute) changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="classDeclarations">Nodes annotated with the [Report] attribute that trigger the generate action.</param>
    private void GenerateCode(SourceProductionContext context, Compilation compilation,
        ImmutableArray<TypeDeclarationSyntax> typeDeclarations)
    {
        foreach (var typeDeclarationSyntax in typeDeclarations)
        {
            var semanticModel = compilation.GetSemanticModel(typeDeclarationSyntax.SyntaxTree);
            if (semanticModel.GetDeclaredSymbol(typeDeclarationSyntax) is not INamedTypeSymbol typeSymbol)
                continue;

            var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
            var className = typeDeclarationSyntax.Identifier.Text;

            // Find properties with the [Updater] attribute




            // Build up the source code
            var code = DefaultCode(namespaceName, className);

            // Add the source code to the compilation.
            context.AddSource($"{className}Base.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }
    
    private static string DefaultCode(string namespaceName, string className) => $@"// <auto-generated/>
using Generators.Domain.Common;

namespace {namespaceName};

public readonly partial record struct {className};";
}
    

